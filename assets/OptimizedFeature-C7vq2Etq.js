import{i as A,e as M}from"./memoryEstimations-DG877__o.js";const y=2;let O=class w{constructor(t=[],e=[]){this.lengths=t??[],this.coords=e??[]}static fromJSON(t){return new w(t.lengths,t.coords)}static fromRect(t){const[e,o,s,n]=t,h=s-e,i=n-o;return new w([5],[e,o,h,0,0,i,-h,0,0,-i])}get isPoint(){return this.lengths.length===0&&this.coords.length>=2}get maxLength(){return Math.max(...this.lengths)}get size(){return this.lengths.reduce((t,e)=>t+e)}get usedMemory(){return 64+A(this.lengths,this.coords)}area(){let t=0,e=0;if(!this.lengths.length)return 0;for(let o=0;o<this.lengths.length;o++){const s=this.lengths[o];if(s<3)continue;let n=this.coords[y*e],h=this.coords[y*e+1];for(let i=1;i<s;i+=1){const l=this.coords[y*(i+e)],g=this.coords[y*(i+e)+1];t+=-.5*(l-n)*(g+h),n=l,h=g}e+=s}return t}forEachVertex(t){let e=0;this.lengths.length||t(this.coords[0],this.coords[1]);for(let o=0;o<this.lengths.length;o++){const s=this.lengths[o];for(let n=0;n<s;n++)t(this.coords[y*(n+e)],this.coords[y*(n+e)+1]);e+=s}}deltaDecode(){const t=this.clone(),{coords:e,lengths:o}=t;let s=0;for(const n of o){for(let h=1;h<n;h++)e[2*(s+h)]+=e[2*(s+h)-2],e[2*(s+h)+1]+=e[2*(s+h)-1];s+=n}return t}clone(t){if(this.lengths.length===0)return new w([],[this.coords[0],this.coords[1]]);const e=(this.lengths.length===0?1:this.lengths.reduce((s,n)=>s+n))*y,o=this.coords.slice(0,e);return t?(t.set(o),new w(this.lengths,t)):new w(Array.from(this.lengths),Array.from(o))}};function S(r,t){return r?t?4:3:t?3:2}function P(r,t,e,o){if(!(t!=null&&t.lengths.length))return null;r.lengths.length&&(r.lengths.length=0),r.coords.length&&(r.coords.length=0);const s=r.coords,n=[],h=e?[Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY]:[Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY],{lengths:i,coords:l}=t,g=S(e,o);let f=0;for(const c of i){const u=G(h,l,f,c,e,o);u&&n.push(u),f+=c*g}if(n.sort((c,u)=>{let m=c[2]-u[2];return m===0&&e&&(m=c[4]-u[4]),m}),n.length){let c=6*n[0][2];s[0]=n[0][0]/c,s[1]=n[0][1]/c,e&&(c=6*n[0][4],s[2]=c!==0?n[0][3]/c:0),(s[0]<h[0]||s[0]>h[1]||s[1]<h[2]||s[1]>h[3]||e&&(s[2]<h[4]||s[2]>h[5]))&&(s.length=0)}if(!s.length){const c=t.lengths[0]?j(l,0,i[0],e,o):null;if(!c)return null;s[0]=c[0],s[1]=c[1],e&&c.length>2&&(s[2]=c[2])}return r}function G(r,t,e,o,s,n){const h=S(s,n);let i=e,l=e+h,g=0,f=0,c=0,u=0,m=0;for(let E=0,F=o-1;E<F;E++,i+=h,l+=h){const I=t[i],d=t[i+1],a=t[i+2],N=t[l],T=t[l+1],p=t[l+2];let V=I*T-N*d;u+=V,g+=(I+N)*V,f+=(d+T)*V,s&&(V=I*p-N*a,c+=(a+p)*V,m+=V),I<r[0]&&(r[0]=I),I>r[1]&&(r[1]=I),d<r[2]&&(r[2]=d),d>r[3]&&(r[3]=d),s&&(a<r[4]&&(r[4]=a),a>r[5]&&(r[5]=a))}if(u>0&&(u*=-1),m>0&&(m*=-1),!u)return null;const b=[g,f,.5*u];return s&&(b[3]=c,b[4]=.5*m),b}function j(r,t,e,o,s){const n=S(o,s);let h=t,i=t+n,l=0,g=0,f=0,c=0;for(let u=0,m=e-1;u<m;u++,h+=n,i+=n){const b=r[h],E=r[h+1],F=r[h+2],I=r[i],d=r[i+1],a=r[i+2],N=o?J(b,E,F,I,d,a):x(b,E,I,d);if(N)if(l+=N,o){const T=q(b,E,F,I,d,a);g+=N*T[0],f+=N*T[1],c+=N*T[2]}else{const T=$(b,E,I,d);g+=N*T[0],f+=N*T[1]}}return l>0?o?[g/l,f/l,c/l]:[g/l,f/l]:e>0?o?[r[t],r[t+1],r[t+2]]:[r[t],r[t+1]]:null}function x(r,t,e,o){const s=e-r,n=o-t;return Math.sqrt(s*s+n*n)}function J(r,t,e,o,s,n){const h=o-r,i=s-t,l=n-e;return Math.sqrt(h*h+i*i+l*l)}function $(r,t,e,o){return[r+.5*(e-r),t+.5*(o-t)]}function q(r,t,e,o,s,n){return[r+.5*(o-r),t+.5*(s-t),e+.5*(n-e)]}class Y{constructor(t=null,e={},o,s,n=0){this.geometry=t,this.attributes=e,this.centroid=o,this.objectId=s,this.displayId=n}static fromJSON(t){const e=t.geometry?O.fromJSON(t.geometry):null,o=t.centroid?O.fromJSON(t.centroid):null,s=t.objectId;return new Y(e,t.attributes,o,s)}weakClone(){const t=new Y(this.geometry,this.attributes,this.centroid,this.objectId);return t.displayId=this.displayId,t}clone(){var o,s;const t=(o=this.geometry)==null?void 0:o.clone(),e=new Y(t,{...this.attributes},(s=this.centroid)==null?void 0:s.clone(),this.objectId);return e.displayId=this.displayId,e}ensureCentroid(t){return this.centroid??(this.centroid=P(new O,this.geometry,t.hasZ,t.hasM)),this.centroid}get usedMemory(){var t;return 128+M(this.attributes)+(((t=this.geometry)==null?void 0:t.usedMemory)??0)}}function _(r){var t,e;return!!((e=(t=r.geometry)==null?void 0:t.coords)!=null&&e.length)}export{O as e,P as n,_ as o,Y as s};
