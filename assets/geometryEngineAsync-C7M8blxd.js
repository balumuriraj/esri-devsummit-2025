import{v as l,e7 as w,ba as h}from"./CodeBlock-DBIw63CI.js";import"./index-BYYG-xAB.js";function n(e){var t;return Array.isArray(e)?(t=e[0])==null?void 0:t.spatialReference:e==null?void 0:e.spatialReference}function p(e){return e&&(Array.isArray(e)?e.map(p):e.toJSON?e.toJSON():e)}function s(e){return Array.isArray(e)?e.map(t=>w(t)):w(e)}function S(e,t){let a;return Array.isArray(e)?a=e:(a=[],a.push(e),t!=null&&a.push(t)),a}let f;async function d(){return f||(f=h("geometryEngineWorker",{strategy:"distributed"})),f}async function r(e,t){return(await d()).invoke("executeGEOperation",{operation:e,parameters:p(t)})}async function m(e,t){const a=await d();return Promise.all(a.broadcast("executeGEOperation",{operation:e,parameters:p(t)}))}function A(e){return r("extendedSpatialReferenceInfo",[e])}async function O(e,t){return s(await r("clip",[n(e),e,t]))}async function D(e,t){return s(await r("cut",[n(e),e,t]))}function J(e,t){return r("contains",[n(e),e,t])}function N(e,t){return r("crosses",[n(e),e,t])}function v(e,t,a){return r("distance",[n(e),e,t,a])}function L(e,t){return r("equals",[n(e),e,t])}function T(e,t){return r("intersects",[n(e),e,t])}function V(e,t){return r("touches",[n(e),e,t])}function b(e,t){return r("within",[n(e),e,t])}function E(e,t){return r("disjoint",[n(e),e,t])}function z(e,t){return r("overlaps",[n(e),e,t])}function H(e,t,a){return r("relate",[n(e),e,t,a])}function j(e){return r("isSimple",[n(e),e])}async function I(e){return s(await r("simplify",[n(e),e]))}async function P(e,t=!1){return s(await r("convexHull",[n(e),e,t]))}async function k(e,t){return s(await r("difference",[n(e),e,t]))}async function q(e,t){return s(await r("symmetricDifference",[n(e),e,t]))}async function B(e,t){return s(await r("intersect",[n(e),e,t]))}async function C(e,t=null){const a=S(e,t);return s(await r("union",[n(a),a]))}async function G(e,t,a,i,c,u){return s(await r("offset",[n(e),e,t,a,i,c,u]))}async function $(e,t,a,i=!1){const c=[n(e),e,t,a,i];return s(await r("buffer",c))}async function W(e,t,a,i,c,u){const g=[n(e),e,t,a,i,c,u];return s(await r("geodesicBuffer",g))}async function F(e,t,a=!0){const i=await r("nearestCoordinate",[n(e),e,t,a]);return{...i,coordinate:l.fromJSON(i.coordinate)}}async function K(e,t){const a=await r("nearestVertex",[n(e),e,t]);return{...a,coordinate:l.fromJSON(a.coordinate)}}async function M(e,t,a,i){return(await r("nearestVertices",[n(e),e,t,a,i])).map(c=>({...c,coordinate:l.fromJSON(c.coordinate)}))}function y(e){var t;return"xmin"in e?e.center:"x"in e?e:(t=e.extent)==null?void 0:t.center}async function Q(e,t,a){if(e==null)throw new o;const i=e.spatialReference;if((a=a??y(e))==null)throw new o;const c=e.constructor.fromJSON(await r("rotate",[i,e,t,a]));return c.spatialReference=i,c}async function U(e,t){if(e==null)throw new o;const a=e.spatialReference;if((t=t??y(e))==null)throw new o;const i=e.constructor.fromJSON(await r("flipHorizontal",[a,e,t]));return i.spatialReference=a,i}async function X(e,t){if(e==null)throw new o;const a=e.spatialReference;if((t=t??y(e))==null)throw new o;const i=e.constructor.fromJSON(await r("flipVertical",[a,e,t]));return i.spatialReference=a,i}async function Y(e,t,a,i){return s(await r("generalize",[n(e),e,t,a,i]))}async function Z(e,t,a){return s(await r("densify",[n(e),e,t,a]))}async function _(e,t,a,i=0){return s(await r("geodesicDensify",[n(e),e,t,a,i]))}function ee(e,t){return r("planarArea",[n(e),e,t])}function te(e,t){return r("planarLength",[n(e),e,t])}function ae(e,t,a){return r("geodesicArea",[n(e),e,t,a])}function re(e,t,a){return r("geodesicLength",[n(e),e,t,a])}async function ne(e,t){return s(await r("intersectLinesToPoints",[n(e),e,t]))}async function ie(e,t){await m("changeDefaultSpatialReferenceTolerance",[e,t])}async function se(e){await m("clearDefaultSpatialReferenceTolerance",[e])}class o extends Error{constructor(){super("Illegal Argument Exception")}}export{$ as buffer,ie as changeDefaultSpatialReferenceTolerance,se as clearDefaultSpatialReferenceTolerance,O as clip,J as contains,P as convexHull,N as crosses,D as cut,Z as densify,k as difference,E as disjoint,v as distance,L as equals,A as extendedSpatialReferenceInfo,U as flipHorizontal,X as flipVertical,Y as generalize,ae as geodesicArea,W as geodesicBuffer,_ as geodesicDensify,re as geodesicLength,B as intersect,ne as intersectLinesToPoints,T as intersects,j as isSimple,F as nearestCoordinate,K as nearestVertex,M as nearestVertices,G as offset,z as overlaps,ee as planarArea,te as planarLength,H as relate,Q as rotate,I as simplify,q as symmetricDifference,V as touches,C as union,b as within};
